<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>危险写作 · 手机优化 & 一键下载TXT（3s后开始模糊）</title>
  <style>
    :root{
      --bg: #0b0f14;
      --panel: #121820;
      --muted: #8aa0b6;
      --text: #e6eef6;
      --accent: #5bbcff;
      --danger: #ff4d6d;
      --ok: #3ddc97;
      --warn: #ffc857;
      --shadow: 0 8px 30px rgba(0,0,0,0.25);
      --radius: 16px;
      --max-blur: 12px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    *{ box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 70% -20%, rgba(91,188,255,.15), transparent),
        linear-gradient(180deg, #0a0f14, #0a1016 45%, #0b1118 100%);
      color: var(--text);
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans", "PingFang SC", "Microsoft YaHei", sans-serif;
      min-height: 100vh; display:flex; align-items:stretch; justify-content:center; padding: 0;
    }
    .app{ width: min(1100px, 100%); display:flex; flex-direction:column; }
    header{
      display:flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px;
    }
    .brand{ display:flex; align-items:center; gap: 8px; }
    .logo{ width: 28px; height: 28px; border-radius: 8px; background: linear-gradient(135deg, var(--accent), #97f4ff); box-shadow: var(--shadow); flex: 0 0 28px; }
    h1{ font-size: 16px; margin:0; letter-spacing:.2px; }
    .controls{
      background: var(--panel); border: 1px solid rgba(255,255,255,0.06);
      border-radius: 12px; padding: 8px; display:flex; gap: 8px; align-items: center; flex-wrap: wrap;
      box-shadow: var(--shadow);
    }
    label{ font-size: 12px; color: var(--muted); }
    input[type="number"]{
      width: 80px; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);
      background: #0d141c; color: var(--text); outline: none; -webkit-appearance: none;
    }
    button{
      padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12);
      background: #0f1722; color: var(--text); cursor: pointer; transition: .2s transform, .2s opacity, .2s background;
      box-shadow: var(--shadow); touch-action: manipulation;
    }
    button:active{ transform: scale(.98); }
    button:hover{ background:#101b28; }
    button:disabled{ opacity:.55; cursor:not-allowed; transform:none; }
    .btn-accent{ background: linear-gradient(180deg, #1a6fa9, #154e79); border-color: rgba(91,188,255,.5); }
    .status{
      margin: 6px 12px; display:flex; align-items:center; gap: 8px; flex-wrap: wrap;
    }
    .pill{
      display:inline-flex; align-items:center; gap: 6px; padding: 5px 10px; border-radius: 999px;
      background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); font-size: 12px; color: var(--muted);
    }
    .pill .dot{ width: 7px; height: 7px; border-radius: 50%; background: var(--warn); box-shadow: 0 0 0 3px rgba(255,200,87,.15); }
    .pill.ok .dot{ background: var(--ok); box-shadow: 0 0 0 3px rgba(61,220,151,.15); }
    .pill.danger .dot{ background: var(--danger); box-shadow: 0 0 0 3px rgba(255,77,109,.15); }
    .meter{ flex:1 1 auto; height: 10px; border-radius: 999px; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.1); overflow: hidden; }
    .meter>span{ display:block; height:100%; width:0%; background: linear-gradient(90deg, #5bbcff, #97f4ff); transition: width .25s linear; }

    .workspace{
      margin: 6px 12px 0; background: var(--panel); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; box-shadow: var(--shadow);
      overflow: hidden; display:flex; flex-direction:column; min-height: 0;
    }
    .promptbar{
      padding: 8px 10px; border-bottom: 1px dashed rgba(255,255,255,0.08); display:flex; gap:8px; align-items:center; background: #0e1520;
    }
    .promptbar label{ color: var(--muted); font-size:12px; }
    .promptbar input{ flex: 1 1 auto; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12); background: #0b121b; color: var(--text); }

    .editor-wrap{ position: relative; flex: 1 1 auto; min-height: 40vh; }
    textarea{
      width:100%; height: 100%; min-height: 50vh; resize: none; padding: 16px; border: none; outline: none; background: transparent; color: var(--text);
      font: 18px/1.75 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      caret-color: var(--accent); transition: filter .15s linear; filter: blur(0px);
      -webkit-user-select: text; user-select: text;
    }
    .idle-overlay{ pointer-events: none; position: absolute; inset: 0;
      background: radial-gradient(120% 60% at 50% 0%, rgba(255,200,87,0.08), transparent 40%) , linear-gradient(180deg, rgba(255,77,109,0), rgba(255,77,109,0.06));
      opacity: 0; transition: opacity .2s ease; }
    .idle-overlay.show{ opacity: 1; }
    .idle-hint{ position: absolute; right: 12px; bottom: 12px; font-size: 12px; color: var(--muted); background: rgba(0,0,0,.35);
      padding: 4px 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.1); pointer-events: none; opacity: 0; transition: opacity .15s linear; }
    .idle-hint.show{ opacity: 1; }

    /* Sticky bottom toolbar for mobile */
    .toolbar{
      position: sticky; bottom: 0; z-index: 5;
      display:flex; align-items:center; justify-content: space-between; gap: 8px; padding: 10px 12px;
      border-top: 1px dashed rgba(255,255,255,0.08); background: #0e1520; padding-bottom: calc(10px + var(--safe-bottom));
    }
    .hint{ color: var(--muted); font-size: 12px; }
    .save-one{
      background: linear-gradient(180deg, #1a6fa9, #154e79);
      border: 1px solid rgba(91,188,255,.5);
      font-weight: 600;
    }

    .footer{ margin: 8px 12px 12px; color: var(--muted); font-size: 12px; text-align:center; }
    .toast{ position: fixed; inset: auto 12px calc(12px + var(--safe-bottom)) auto; background: #061018; border: 1px solid rgba(255,255,255,.12); color: var(--text);
      padding: 10px 12px; border-radius: 12px; box-shadow: var(--shadow); display:none; z-index: 50; }
    @media (max-width: 640px){
      body{ font-size: 15px; }
      textarea{ font-size: 17px; }
    }
  
    /* --- Keep last line visible above sticky toolbar (v2) --- */
    :root{ --tb: 0px; }
    /* Give the editor room; some browsers ignore textarea padding when computing scroll */
    .editor-wrap{ padding-bottom: calc(8px + var(--tb) + env(safe-area-inset-bottom)); }
    /* Also add internal cushion so caret stays above the bar even when the page can't scroll */
    textarea{
      padding-bottom: calc(16px + var(--tb) + env(safe-area-inset-bottom));
      /* Make sure the padding actually creates scrollable space inside the textarea */
      box-sizing: border-box;
      scroll-padding-bottom: calc(16px + var(--tb) + env(safe-area-inset-bottom));
    }

  </style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <h1>危险写作 · 手机优化 & 一键下载TXT（3s后开始模糊）</h1>
      </div>
      <div class="controls" aria-label="会话设置">
        <label>时长(分钟)<br /><input id="minutes" type="number" min="1" step="1" value="60"></label>
        <label>失活惩罚(秒)<br /><input id="idle" type="number" min="1" step="1" value="5"></label>
        <button id="startBtn" class="btn-accent">开始写作</button>
      </div>
    </header>

    <div class="status">
      <div id="timerPill" class="pill"><span class="dot" aria-hidden="true"></span><span id="timer">尚未开始</span></div>
      <div id="statePill" class="pill"><span class="dot" aria-hidden="true"></span><span id="stateText">等待开始</span></div>
      <div class="meter" aria-label="时间进度"><span id="meterFill"></span></div>
    </div>

    <section class="workspace">
      <div class="promptbar">
        <label for="prompt">题目/提示：</label>
        <input id="prompt" placeholder="可选：写点什么主题（不影响规则）" />
      </div>
      <div class="editor-wrap">
        <textarea id="editor" placeholder="开始后请持续输入。超过“失活惩罚(秒)”未输入将清空全文。" disabled></textarea>
        <div id="idleOverlay" class="idle-overlay"></div>
        <div id="idleHint" class="idle-hint">失活倒计时：<span id="idleLeft">—</span>s</div>
      </div>

      <div class="toolbar">
        <div class="hint" id="hintText">快捷：Ctrl+Enter 开始/完成；Ctrl+S 保存TXT</div>
        <div class="wordcount" id="wordCount">字数: 0</div>

        <div>
          <button id="saveBtn" class="save-one" style="display:none;" disabled>保存TXT</button>
          <button id="copyBtn" style="display:none;" disabled>复制全文</button>
        </div>
      </div>
    </section>

    <div class="footer">
      说明：3秒“宽限期”后才开始模糊；点击“保存TXT”会直接触发浏览器下载（不使用系统分享）。
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<script>
(function(){
  const minutesEl = document.getElementById('minutes');
  const idleEl = document.getElementById('idle');
  const startBtn = document.getElementById('startBtn');

  // --- v2: robust bottom offset for sticky toolbar + keyboard ---
  const toolbarEl = document.querySelector('.toolbar');
  const ta = document.getElementById('editor');

  function measureToolbar(){
    let h = 0;
    try{
      h = toolbarEl ? Math.max(toolbarEl.offsetHeight, toolbarEl.getBoundingClientRect().height) : 0;
      document.documentElement.style.setProperty('--tb', `${h}px`);
    }catch(e){}
    return h;
  }

  function bumpScrollIfNearBottom(){
    if(!ta) return;
    // If the remaining scrollable space at the bottom is less than toolbar height + cushion,
    // push the scroll further so the caret/last line sits above the bar.
    const tb = toolbarEl ? toolbarEl.getBoundingClientRect().height : 0;
    const cushion = 24;
    const remaining = (ta.scrollHeight - ta.scrollTop) - ta.clientHeight;
    if (remaining < tb + cushion){
      ta.scrollTop = Math.min(ta.scrollHeight, ta.scrollTop + (tb + cushion - remaining));
    }
  }

  // Recompute on layout changes and when controls toggle
  function updateLayout(){
    measureToolbar();
    // Only bump scroll when focused/typing (prevents unwanted jumps)
    if (document.activeElement === ta) bumpScrollIfNearBottom();
  }

  // Listeners for device rotations, viewport changes (keyboard), and UI toggles
  ['resize','orientationchange'].forEach(ev => window.addEventListener(ev, updateLayout));
  if (window.visualViewport){
    window.visualViewport.addEventListener('resize', updateLayout);
  }

  // React to potential toolbar height changes (e.g., buttons show/hide)
  const mo = new MutationObserver(updateLayout);
  if (toolbarEl){ mo.observe(toolbarEl, { attributes:true, childList:true, subtree:true }); }

  // When typing, keep the last line above the bar
  if (ta){
    ['input','keyup','focus'].forEach(ev => ta.addEventListener(ev, updateLayout));
  }

  // Initial
  requestAnimationFrame(updateLayout);
  setTimeout(updateLayout, 300);


  const timerEl = document.getElementById('timer');
  const timerPill = document.getElementById('timerPill');
  const statePill = document.getElementById('statePill');
  const stateText = document.getElementById('stateText');
  const editor = document.getElementById('editor');
  const meterFill = document.getElementById('meterFill');
  const promptInput = document.getElementById('prompt');
  const saveBtn = document.getElementById('saveBtn');
  const copyBtn = document.getElementById('copyBtn');
  const toast = document.getElementById('toast');
  const idleOverlay = document.getElementById('idleOverlay');
  const idleLeftEl = document.getElementById('idleLeft');
  const idleHint = document.getElementById('idleHint');
  const hintText = document.getElementById('hintText');

  let running = false;
  let startAt = 0;
  let endAt = 0;
  let countdownTimer = null;
  let idleTimer = null;
  let idleBlurTicker = null;
  let lastInputAt = 0;

  const BLUR_GRACE_MS = 3000; // 3s grace before blur starts

  function fmt(ms){
    if (ms < 0) ms = 0;
    const s = Math.floor(ms/1000);
    const m = Math.floor(s/60);
    const sec = s % 60;
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
  function setPill(el, level, text){
    el.classList.remove('ok','danger');
    if(level==='ok') el.classList.add('ok');
    if(level==='danger') el.classList.add('danger');
    if(text) {
      if(el === statePill) stateText.textContent = text;
      if(el === timerPill) timerEl.textContent = text;
    }
  }
  function lockControls(lock){
    minutesEl.disabled = lock;
    idleEl.disabled = lock;
    startBtn.disabled = lock;
    editor.disabled = !lock ? true : false;
    saveBtn.style.display = lock ? 'inline-flex' : 'none';
    copyBtn.style.display = lock ? 'inline-flex' : 'none';
    const disabled = editor.value.length === 0;
    saveBtn.disabled = disabled;
    copyBtn.disabled = disabled;
    if(lock){ editor.focus(); }
  }
  function showToast(msg){
    toast.textContent = msg;
    toast.style.display = 'block';
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.style.display='none', 2400);
  }

  function start(){
    const mins = Math.max(1, parseInt(minutesEl.value || '1', 10));
    const idleSec = Math.max(1, parseInt(idleEl.value || '5', 10));
    const duration = mins * 60 * 1000;

    editor.value = '';
    running = true;
    startAt = Date.now();
    endAt = startAt + duration;
    lastInputAt = Date.now();

    setPill(statePill, 'ok', '进行中 · 持续输入');
    setPill(timerPill, '', fmt(duration));
    meterFill.style.width = '0%';
    lockControls(true);
    resetIdleTimer();

    countdownTimer = setInterval(()=>{
      const now = Date.now();
      const left = endAt - now;
      timerEl.textContent = fmt(left);
      const progress = Math.min(100, Math.max(0, ((now - startAt) / (endAt - startAt)) * 100));
      meterFill.style.width = progress + '%';
      timerPill.style.filter = (left <= 15000 && left > 0) ? 'drop-shadow(0 0 12px rgba(91,188,255,.35))' : 'none';
      if(left <= 0){ finishSuccess(); }
    }, 200);

    window.onbeforeunload = (e)=>{ if(running) { e.preventDefault(); e.returnValue = ''; return ''; } };
    showToast('会话已开始，保持输入！');
  }

  function beginIdleBlurTicker(){
    clearInterval(idleBlurTicker);
    idleOverlay.classList.add('show');
    idleHint.classList.add('show');
    idleBlurTicker = setInterval(()=>{
      if(!running) return;
      const idleSec = Math.max(1, parseInt(idleEl.value || '5', 10));
      const idleMs = idleSec * 1000;
      const elapsedMs = Date.now() - lastInputAt;
      const remain = Math.max(0, idleMs - elapsedMs);
      idleLeftEl.textContent = (remain/1000).toFixed(1);

      // remap progress: 0 at BLUR_GRACE_MS, 1 at idleMs
      let progress = 0;
      if (elapsedMs > BLUR_GRACE_MS) {
        const denom = Math.max(1, idleMs - BLUR_GRACE_MS);
        progress = Math.min(1, (elapsedMs - BLUR_GRACE_MS) / denom);
      }
      const maxBlur = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--max-blur')) || 12;
      const blur = progress * maxBlur;
      editor.style.filter = `blur(${blur.toFixed(2)}px)`;
      idleOverlay.style.opacity = remain <= 1200 ? 1 : 0.9 * progress;
    }, 80);
  }
  function stopIdleBlurTicker(){
    clearInterval(idleBlurTicker);
    idleOverlay.classList.remove('show');
    idleHint.classList.remove('show');
    editor.style.filter = 'blur(0px)';
  }
  function resetIdleTimer(){
    clearTimeout(idleTimer);
    stopIdleBlurTicker();

    // Schedule blur ticker to start after grace, but keep wipe at full idle timeout
    const idleSec = Math.max(1, parseInt(idleEl.value || '5', 10));
    const idleMs = idleSec * 1000;
    const delay = Math.max(0, Math.min(BLUR_GRACE_MS, idleMs - 100)); // avoid negative if idle < 3s
    setTimeout(()=>{
      if(!running) return;
      if(Date.now() - lastInputAt >= delay){ beginIdleBlurTicker(); }
    }, delay);

    idleTimer = setTimeout(()=>{
      if(!running) return;
      editor.value = '';
      stopCore();
      setPill(statePill, 'danger', `已清空：超过 ${idleEl.value}s 未输入`);
      showToast('超过失活时长，全文已清空。');
      stopIdleBlurTicker();
      lockControls(false);
    }, idleMs);
  }

  function finishSuccess(){
    stopCore();
    setPill(statePill, 'ok', '完成！可保存TXT');
    setPill(timerPill, 'ok', '00:00');
    showToast('恭喜完成！现在可保存TXT。');
    stopIdleBlurTicker();
    lockControls(false);
  }
  function stopCore(){
    running = false;
    clearInterval(countdownTimer);
    clearTimeout(idleTimer);
    window.onbeforeunload = null;
  }

  async function oneTapDownload(){
    const text = editor.value || '';
    if(!text){ showToast('没有内容可保存'); return; }
    const title = (promptInput.value || 'dangerous-writing').slice(0,60).trim() || 'dangerous-writing';
    const stamp = new Date().toISOString().replace(/[:.]/g,'-');
    const filename = `${title}__${stamp}.txt`;
    const blob = new Blob([text], {type: 'text/plain;charset=utf-8'});

    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
    showToast('已触发下载，请到“文件/下载”中查看');
  }

  async function copyAll(){
    const text = editor.value || '';
    if(!text){ showToast('没有内容可复制'); return; }
    try{
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(text);
      } else {
        // Fallback: temporarily select and execCommand
        const prev = { start: editor.selectionStart, end: editor.selectionEnd, focus: document.activeElement === editor };
        editor.select();
        document.execCommand('copy');
        // restore selection/focus
        if(prev.focus){ editor.focus(); editor.setSelectionRange(prev.start, prev.end); }
      }
      showToast('已复制到剪贴板');
    }catch(e){
      console.error(e);
      showToast('复制失败：浏览器权限或安全策略限制');
    }
  }

  // events
  startBtn.addEventListener('click', start);
  saveBtn.addEventListener('click', oneTapDownload);
  copyBtn.addEventListener('click', copyAll);

  editor.addEventListener('input', ()=>{
    lastInputAt = Date.now();
    if(running){ resetIdleTimer(); }
    const disabled = editor.value.length === 0;
    saveBtn.disabled = disabled;
    copyBtn.disabled = disabled;
  });

  // shortcuts（桌面端为主，移动端键盘可能不支持）
  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' && (e.ctrlKey || e.metaKey)){
      e.preventDefault();
      if(!running) start(); else finishSuccess();
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's'){
      e.preventDefault(); oneTapDownload();
    }
    if((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'c'){
      e.preventDefault(); copyAll();
    }
  });

  // Parse ?limit=60&type=minutes
  (function initFromQuery(){
    const params = new URLSearchParams(location.search);
    const type = params.get('type');
    const limit = parseInt(params.get('limit') || '0', 10);
    if(type === 'minutes' && limit > 0){ minutesEl.value = limit; }
  
  // 字数统计
  const wordCountEl = document.getElementById('wordCount');
  function updateWordCount(){
    const text = editor.value;
    wordCountEl.textContent = '字数: ' + text.length;
  }
  editor.addEventListener('input', updateWordCount);

})();

  // 字数统计
  const wordCountEl = document.getElementById('wordCount');
  function updateWordCount(){
    const text = editor.value;
    wordCountEl.textContent = '字数: ' + text.length;
  }
  editor.addEventListener('input', updateWordCount);

})();
</script>
</body>
</html>
